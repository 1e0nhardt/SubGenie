import logging
import os
import re
import time
from http import HTTPStatus
from pathlib import Path
from typing import Union

import dashscope
import requests
from numpy import void
from PIL import Image, ImageOps
from pydub import AudioSegment
from rich.console import Console
from rich.logging import RichHandler
from rich.table import Table
from rich.traceback import install
from torch import ge, mode


class MyFilter(logging.Filter):
    def __init__(self, name: str = "") -> None:
        super().__init__(name)
        self.pys = []  # 记录项目所有的py文件
        for _, _, i in os.walk(os.path.dirname(__file__)):
            self.pys.extend([j for j in i if j.endswith('py')])
        # CONSOLE.print(self.pys)

    def filter(self, record):
        if record.filename in self.pys:
            return True
        return False

FORMAT = "%(message)s"
rich_handler = RichHandler(markup=True)
rich_handler.addFilter(MyFilter())
logging.basicConfig(
    level=logging.DEBUG, format=FORMAT, datefmt="[%X]", handlers=[rich_handler])

LOGGER = logging.getLogger("rich")
CONSOLE = Console()

install(show_locals=False)

dashscope.api_key = os.getenv("DASHSCOPE_API_KEY")

# Whisper模型默认的采样率
SAMPLE_RATE = 16000

ASS_TEMPLAT = """[Script Info]
; Script generated by SubGenie
; https://github.com/1e0nhardt/SubGenie
ScriptType: v4.00+
ScaledBorderAndShadow: Yes
PlayResX: 1920
PlayResY: 1080
WrapStyle: 0

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: EN,Resource Han Rounded CN Regular,40,&H00FFFFFF,&HF0000000,&H00000000,&H32000000,0,0,0,0,100,100,0,0,1,2,1,2,5,5,15,1
Style: ZH,Resource Han Rounded CN Regular,64,&H00FFFFFF,&HF00000FF,&H00000000,&H32000000,-1,0,0,0,100,100,0,0,1,2,1,2,10,10,10,1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
"""

_input_price_dict = {
    "qwen-turbo": 0.002 / 1000,
    "qwen-plus": 0.004 / 1000,
    "qwen-max": 0.04 / 1000,
}

_output_price_dict = {
    "qwen-turbo": 0.006 / 1000,
    "qwen-plus": 0.012 / 1000,
    "qwen-max": 0.12 / 1000,
}

def get_input_token_price(model):
    return _input_price_dict.get(model, 0)

def get_output_token_price(model):
    return _output_price_dict.get(model, 0)


class TimeRecorder:
    def __init__(self):
        self._start_time = 0
        self._record = {}

    def reset(self):
        self._start_time = time.time()
    
    def record(self, description):
        self._record[description] = time.time() - self._start_time
        self._start_time = time.time()
    
    def show(self, title: str = "Time Cost"):
        table = Table(title=title, show_header=False)
        table.add_column('Code Piece', style='cyan')
        table.add_column('Time Cost', style='magenta')
        for k, v in self._record.items():
            table.add_row(k, str(v))

        CONSOLE.line(1)
        CONSOLE.print(table)

TIME_RECORDER = TimeRecorder()

class ApiUsageRecorder:
    def __init__(self):
        self._record = {}

    def record(self, model, usage):
        if self._record.get(model, None):
            self._record[model]["input_tokens"] += usage["input_tokens"]
            self._record[model]["output_tokens"] += usage["output_tokens"]
        else:
            self._record[model] = {
                "input_tokens": usage["input_tokens"],
                "output_tokens": usage["output_tokens"],
            }
    
    def show(self, title: str = "Api Usage"):
        table = Table(title=title, show_header=True)
        table.add_column('Model', justify="center", style='cyan')
        table.add_column('Input Tokens', justify="center", style='magenta')
        table.add_column('Output Tokens', justify="center", style='magenta')
        table.add_column('Cost(￥)', justify="center", style='gold1')
        for k, token_dict in self._record.items():
            price = round(token_dict["input_tokens"] * get_input_token_price(k) + token_dict["output_tokens"] * get_output_token_price(k), 5)
            table.add_row(k, str(token_dict["input_tokens"]), str(token_dict["output_tokens"]), str(price))

        CONSOLE.line(1)
        CONSOLE.print(table)

API_USAGE_RECORDER = ApiUsageRecorder()

def qwen_call_once(content, model="qwen-turbo") -> str:
    messages = [{'role': 'system', 'content': 'You are a helpful assistant.'},
                {'role': 'user', 'content': content}]
    response = dashscope.Generation.call(
        model,
        messages=messages,
        result_format='message',  # 将返回结果格式设置为 message
    )
    if response.status_code == HTTPStatus.OK:
        # print(f"token使用情况: {response.usage}")
        API_USAGE_RECORDER.record(model, response.usage)
        return response.output.choices[0].message.content
    else:
        print('Request id: %s, Status code: %s, error code: %s, error message: %s' % (
            response.request_id, response.status_code,
            response.code, response.message
        ))
        return ""


# 封装模型的响应函数
def get_response(last_messages, model="qwen-max"):
    body = {
        'model': model,
        "input": {
            "messages": last_messages
        },
        "parameters": {
            "result_format": "message"
        }
    }
    response = requests.post(
        'https://dashscope.aliyuncs.com/api/v1/services/aigc/text-generation/generation', 
        headers={'Content-Type': 'application/json',
                'Authorization': f'Bearer {dashscope.api_key}'}, 
        json=body)
    response_json = response.json()
    API_USAGE_RECORDER.record(model, response_json["usage"])
    return response_json


def qwen_translate(content: str, model="qwen-max") -> str:
    # turbo限流阈值
    # 每分钟不超过500次API调用；
    # 每分钟消耗的token数目不超过500,000。
    messages = [
        {
            "role": "system",
            "content": \
"""请你扮演专业翻译员的角色。将各种语言精准而优雅地转化为尽量简短的中文。请在翻译时避免生硬的直译，而是追求自然流畅、贴近原文。不要进行任何格式修改
**注意事项**：
- 严格保留每行开头的时间格式，示例"[1.44->3.18]"。
- 逐行翻译。
- 不要输出任何与翻译结果无关的内容。

**翻译示例**：
原文：
[44.06->45.72]So let's open up the project,

翻译结果：
[44.06->45.72]我们打开项目，
"""   
        }
    ]

    prompts = [
        content,
    ]
    
    for i in range(len(prompts)):
        messages.append({
            "role": "user",
            "content": prompts[i]
        })
        response = get_response(messages, model)
        assistant_output = response['output']['choices'][0]['message']
        if i < len(prompts) - 1:
            messages.append(assistant_output)
            # print(messages)
        else:
            print(assistant_output['content'])
            print(f"{response['usage']}" )
            return assistant_output['content']


def get_timestamp(t, ass=True):
    """1234.12 -> xx:xx:xx,xxx (h:m:s,ms)"""
    t = float(t)
    seconds = int(t)
    ms = t - seconds
    minutes = seconds // 60
    seconds %= 60
    hours = minutes // 60
    minutes %= 60
    if ass:
        ms = f'{round(ms, 2):.2f}'[2:]
        return f'{hours}:{minutes:02d}:{seconds:02d}.{ms}'
    else:
        ms = f'{round(ms, 3):.3f}'[2:]
        return f'{hours:02d}:{minutes:02d}:{seconds:02d},{ms}'


def filter_files(path: Union[Path|str], filter_str) -> list[Path]:
    """
    根据指定的文件后缀名过滤路径下的文件。

    参数:
    path: Union[Path|str] - 文件路径，可以是Path对象或字符串。
    filter_str: str - 用逗号分隔的文件后缀名字符串。

    返回:
    list[Path] - 符合过滤条件的文件路径列表，每个元素是Path对象。
    """
    if isinstance(path, str): 
        path = Path(path)

    suffixs = filter_str.split(",")
    glob_pats = [f"*.{s.strip()}" for s in suffixs]
    ret_lst = []
    for pat in glob_pats:
        ret_lst.extend(list(path.glob(pat)))
    return ret_lst


def write_ass_subtitle(translated_line_lst: list[str], srt_path: Path) -> void:
    """
    将翻译后的字幕行写入到ASS或SRT字幕文件中。

    :param translated_line_lst: 包含翻译后字幕行的列表。
    :param srt_path: 字幕文件的路径，可以是ASS或SRT格式。
    """
    pattern = re.compile(r"^\[(\d+\.\d+)->(\d+\.\d+)\](.*)@@@(.*)$")
    line_format = "Dialogue: %d,%s,%s,ZH,,0,0,0,,%s\\N{\\rEN}%s\n"

    with srt_path.open("w", encoding="utf-8") as f:
        if srt_path.suffix == '.ass':
            f.write(ASS_TEMPLAT)

        for i, line in enumerate(translated_line_lst):
            if line == "":
                continue
            if srt_path.suffix == '.ass':
                line_id = 0
            else:
                line_id = i + 1

            match = pattern.match(line.strip())
            if match is None:
                # API翻译结果有时候会出现"\u200b"，导致正则匹配失败，去掉再试一次。
                line = line.replace("\u200b", "") 
                match = pattern.match(line.strip())
                if match is None:
                    print("[red]匹配失败: %s" % line)
                    continue
            start, end, source_text, target_text = match.groups()
            f.write(line_format % (line_id, get_timestamp(start), get_timestamp(end), target_text, source_text))

def ensure_folder_exists(path: str):
    if not os.path.exists(path):
        LOGGER.info(f'[red]Directory {path} does not exist, creating...[/]')
        os.makedirs(path, exist_ok=True)


# 从视频文件提取音轨
def extract_sound_from_video(video_path, sound_save_path, format='wav'):
    AudioSegment.from_file(video_path).export(sound_save_path, format=format)


def resize_image(input_image_path, output_image_path, size):
    with Image.open(input_image_path) as image:
        resized_image = image.resize(size)
        resized_image.save(output_image_path)


def sbcover_pad(image_path, output_path=None, color=None):
    """
    使用Pillow对图像进行Padding
    :param image_path: 图像路径
    :param output_path: 图像输出路径
    :param color: 填充颜色，默认图像中出现最多的颜色
    :return: None
    """
    image = Image.open(image_path)
    w, h = image.size
    if color is None:
        color = sorted(image.getcolors(w*h), key=lambda x: x[0], reverse=True)[0][1]
    pad_size = ((w * 0.75) - h) / 2
    pad_size = int(pad_size)
    if pad_size <= 0:
        return
    
    padded_image = ImageOps.expand(image, border=(0, pad_size, 0, pad_size), fill=color)
    
    if output_path:
        padded_image.save(output_path)
    else:
        padded_image.save('padded_image.png')


if __name__ == '__main__':
    # image_path = Path('assets\misc\Shop and Treasure Room for a Roguelike Deckbuilder in Godot (S02E12).jpg')
    # sbcover_pad(
    #     image_path,
    #     image_path.parent / ("Padded_" + image_path.name),
    # )

    ret = qwen_translate("""[0.00->2.94]Hi, I'm Adam, welcome back to Godot Gamelab.
[3.00->7.30]In this video we'll create the bread and butter of this project, the card-dragging mechanic.
[7.64->13.26]In Slay the Spire we have two kinds of cards regarding this, single targeted and non-single targeted.
[13.60->15.00]Let's start with the easier one.
[15.22->20.52]If I start dragging the defend card and release it somewhere above the hand, the card gets played.
[21.08->24.90]Another way to do this is to left click the defend card once,
[25.65->29.02]start moving the mouse without holding the left mouse button and click again.
[30.00->32.64]Also, there are two ways to cancel the movement.
[33.68->38.46]You can either right click, or finish the card dragging below the play area.
[38.76->41.00]So let's see how this looks like in our game.
[41.20->44.94]You can see that we have this big card drop area on the top,
[45.10->48.28]and we have three cards in their base state in our hand.
[49.20->53.86]If I hover over a card and left click once, it goes to this dragging state,
[54.20->57.28]and I can drag the card over the card drop area,
[57.38->65.24]and if I click again with the left mouse button, it gets released and we have a debug message saying play the card for target's card drop area.
[67.82->75.28]Now, if we drag another one and we release it under the card drop area, it snaps back to the hand of the player.
[75.28->84.02]and also, if I start dragging this card, drag it over the card drop area and right-click, it snaps back to the hand of the player too.
[84.44->86.92]So this works exactly just like we saw in the video.
[87.90->88.84]Let's get started.
[89.04->92.52]So let's open up the project and start creating the card dragging mechanic.
[93.20->101.14]For the cards themselves, we'll use a combination of control nodes to display them and an area 2d to handle the card drop area logic.
[102.56->104.72]So let's start by creating a new scene.
[104.90->110.66]Click on this plus sign to add a new scene and this time we'll start with a user interface node as a root node,
[110.66->111.50]a control node.
[111.50->112.52]click on it.
[112.52->116.54]click on the control to rename this to card ui.
[116.54->120.90]we want to add two child nodes to this.
[120.90->125.36]so click on the plus sign or press ctrl a and first let's add a color rect.
[126.18->133.60]this will be a temporary color we use so we can differentiate between the different states visually for debugging purposes.
[133.60->138.06]add this color rect, click on this and rename this to color
[139.68->141.92]and select the card UI, the root node.
[141.92->142.18]again.
[142.36->146.42]click on the plus sign again and press ctrl a and add a label node too.
[148.80->151.70]Click on the label node and rename this to state.
[153.06->155.82]Now let's zoom in to see what's going on a bit better.
[159.02->161.62]And for the card UI, let's set a size,
[161.78->163.26]a proper size, for this.
[163.36->172.38]so go to layout, transform form and set the size to something like 25 by 30.
[172.38->175.24]it already looks much better,
[175.96->176.96]much like a card,
[176.96->182.82]so let's make sure that the color is inheriting this size.
[183.24->189.24]so let's go to the color, select this node and, under anchor presets, select full rect.
[191.06->196.54]and while we're here, we can change this color to something more pleasant, like a dark green maybe.
[198.92->205.22]so let's select a dark green color, something like this.
[205.22->206.98]and for the state,
[208.48->218.42]just write state for the text property of the label and make sure it's aligned to the center on the horizontal and the vertical axis as well,
[218.42->221.64]and also make sure that it's
[222.54->224.10]inheriting the size from the parent node.
[224.64->228.46]So again click on anchor preset and set full rect.
[228.64->234.94]You can see that the text is much bigger than the card itself and this is what we have to address next.""", "qwen-turbo")
    # qwen-plus的结果没有时间戳。turbo有，但还是会吞行。
    # max结果正确。
    print(ret)
